# 스코프(Scope; 유효범위)

## 변수의 스코프

* 객체와 함수는 변수(variable)
* 변수의 스코프는 해당 변수가 접근할 수 있는 변수, 객체, 함수의 집합을 뜻한다.
* 유효범위에 따라 지역 변수와 전역 변수로 구분

<br>

### 지역 변수(Local Variable)

* 함수 내에서 선언된 변수(반드시 var 키워드 사용)
* 선언된 함수 내에서만 유효
* 함수가 종료되면 메모리에서 사라짐(스택영역)
* 함수의 매개변수도 지역변수처럼 동작

<br>

### 전역 변수(Global Variable)

* 함수의 외부에서 선언
  * var 키워드로 선언한 전역변수는 전역 객체 `window`의 프로퍼티
* 프로그램의 어느 영역에서나 접근
* 웹 페이지가 닫혀야 메모리에서 사라짐(데이터 영역)
  * 따라서, 서로 분리된 js파일에 같은 이름의 전역 변수가 있을 경우 HTML에서 함께 로드한다면 변수가 중복된다.
  * 즉시실행함수(IIFE, Immediately-Invoked Function Expression)을 이용하여 전역변수 사용을 억제할 수 있다.
* 함수의 내부에서 var 키워드 없이 함수를 선언하면 전역 변수로 간주
  * 암묵적 전역 변수(implicit global); 오류의 원인이 될 가능성이 크다.
* 전역 변수와 같은 이름의 지역변수를 선언하면, 해당 블록에서는 지역변수만 호출 가능
	* window객체의 프로퍼티임을 명시하면 호출 가능

<br>

## 함수의 스코프
* 렉시컬 특성을 가진다.

* 통상적으로 렉시컬 특성을 가지는 언어들은 블록 내에서 정의된 변수를 블록 외부에서 접근할 수 없다.(블록 단위 스코프, block-level scope)

* 자바스크립트는 함수를 블록 대신 사용
	
	* 함수단위 스코프(function-level scope)
		
	* 함수안에서 선언된 변수 및 함수는 해당 함수안 어디서든 사용 가능하다.
	
	* ES6 부터 블록 레벨 스코프를 사용할 수 있는`let` 키워드 도입
	
	  ```js
	  function f1(){
	      if(true){var a = 10;}
	      console.log(a); // 블록이 스코프를 가지지 않기 때문에 호출 가능
	  }
	  ```
	
	  ```js
	  if(true){
	  	var a = 10; // 마찬가지로, 블록이 스코프를 가지지 않기 때문에 a는 전역 변수로 생성된다.
	  }
	  console.log(a);
	  >> 10
	  
	  function f3(){
	      console.log(a);
	  }
	  f3()
	  >> 10;
	  ```
	
	  
	
* 전역 함수는 모든 전역 변수와 전역 함수에 접근 가능

<br>

### 렉시컬 스코프(Lexical Scoping; 유효범위, Static Scoping)

* 함수가 실행되는 시점이 아니라, 함수가 정의된 시점을 기준으로 스코프가 생성되는 것
  * 다이나믹스코프 : 함수가 실행되는 시점을 기준으로 스코프 생성

* 호이스팅으로 인해 함수 안에서 다른 함수를 호출하는 것은 가능하다.
* 하지만 다른 함수 안에 있는 변수를 참조하지는 못한다.
```js
function f1(){
    var a = 10;
    console.log(a);
}
function f2(){
    f1();
    console.log(a); /* 함수가 스코프를 가지기 때문에 호출 불가
    				 * 만약 동적 스코프가 적용된다면 a 호출 가능 */    				 
}
f2();
>> 10
>> VM1266:3 Uncaught ReferenceError: a is not defined
```

<br>

## 함수 호이스팅(Hoisting)

* 스코프(유효범위)적용이 변수가 선언 되기 전에도 적용된다.
* 이것을 함수 호이스팅이라 한다.
* 즉, 함수 안에 있는 모든 변수의 선언은 함수의 맨 처음에 선언된 것처럼 동작한다.